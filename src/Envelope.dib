#!csharp

#r "nuget: Hypar.Elements, *-*"
#r "nuget: Hypar.Functions, *-*"
#r "/Users/andrewheumann/Dev/Envelope/src/bin/Debug/netcoreapp3.1/CreateEnvelopes.dll"
#r "/Users/andrewheumann/Dev/Envelope/src/bin/Debug/netcoreapp3.1/CreateEnvelopes.Dependencies.dll"
using CreateEnvelopes;
using System.IO;
using Newtonsoft.Json;

#!csharp

public static List<Elements.Envelope> CreateDefaultEnvelopes(Model siteModel, Model siteConstraintsModel, EnvelopeInputs input) {
    var list = new List<Elements.Envelope>();
    return list;
}

#!csharp

public static EnvelopeOutputs Execute(Dictionary<string, Model> inputModels, EnvelopeInputs input)
{
    var output = new EnvelopeOutputs();
    var hasSite = inputModels.TryGetValue("Site", out var siteModel);
    var hasSiteConstraints = inputModels.TryGetValue("Site Constraints", out var siteConstraintsModel);
    var defaultEnvelopes = CreateDefaultEnvelopes(siteModel, siteConstraintsModel);
    var overriddenEnvelopes = input.Overrides.Massing.CreateElements(
        input.Overrides.Additions.Massing,
        input.Overrides.Removals.Massing,
        (add) => {
            return new Envelope(add);
        },
        (elem, identity) => {
            return elem.AddId == identity.Value.AddId;
        },
        (elem, edit) => {
            
        },
        defaultEnvelopes);
    return output;
}

#!csharp

public EnvelopeInputs GetInput()
{
    var json = File.ReadAllText("../test/Generated/EnvelopeTest/inputs.json");
    return Newtonsoft.Json.JsonConvert.DeserializeObject<EnvelopeInputs>(json);
}
var input = GetInput();
var modelDependencies = new Dictionary<string, Model> { 
    {"Site", Model.FromJson(File.ReadAllText(@"../test/Generated/EnvelopeTest/model_dependencies/Site/ca5033d8-8bb9-43e5-b070-a2e361982465.json")) }, 
    {"Site Constraints", Model.FromJson(File.ReadAllText(@"../test/Generated/EnvelopeTest/model_dependencies/Site Constraints/4a817994-21da-4eba-9469-0ee44d5c4d10.json")) }, 
};
var output = Execute(modelDependencies, input);
output.Model.AddElements((modelDependencies["Site"].Elements.Values));
output.Model.AddElements((modelDependencies["Site Constraints"].Elements.Values));
return output.Model;

#!csharp

public Model DrawCurves(IEnumerable<Curve> curves) {
    var model = new Model();
    foreach (var curve in curves) {
        model.AddElement(new ModelCurve(curve, BuiltInMaterials.XAxis));
    }
    return model;
}

#!csharp

var lineJson = "[{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-185.87475812316617,\"Y\":10.59616806069089,\"Z\":0.0},\"End\":{\"X\":-253.05018972591094,\"Y\":10.163183974111167,\"Z\":0.0}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-253.08948111588975,\"Y\":16.259057152611177,\"Z\":0.0},\"End\":{\"X\":-277.42988663579314,\"Y\":-45.367092465552034,\"Z\":-5.10702591327572E-14}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-277.42988663579314,\"Y\":-45.367092465552034,\"Z\":-5.10702591327572E-14},\"End\":{\"X\":-185.914049513145,\"Y\":-44.93410837897232,\"Z\":0.0}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-188.962049902464,\"Y\":-44.93411,\"Z\":0.0},\"End\":{\"X\":-188.962049902464,\"Y\":16.69204,\"Z\":0.0}}]";
var lines = JsonConvert.DeserializeObject<List<Line>>(lineJson);

#!csharp

var siteSegmentJson = "[{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-185.914049513145,\"Y\":16.6920412391909,\"Z\":0.0},\"End\":{\"X\":-253.08948111588975,\"Y\":16.259057152611177,\"Z\":0.0}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-253.08948111588975,\"Y\":16.259057152611177,\"Z\":0.0},\"End\":{\"X\":-277.42988663579314,\"Y\":-45.367092465552034,\"Z\":-5.10702591327572E-14}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-277.42988663579314,\"Y\":-45.367092465552034,\"Z\":-5.10702591327572E-14},\"End\":{\"X\":-185.914049513145,\"Y\":-44.93410837897232,\"Z\":0.0}},{\"discriminator\":\"Elements.Geometry.Line\",\"Start\":{\"X\":-185.914049513145,\"Y\":-44.93410837897232,\"Z\":0.0},\"End\":{\"X\":-185.914049513145,\"Y\":16.6920412391909,\"Z\":0.0}}]";
var siteSegments = JsonConvert.DeserializeObject<List<Line>>(siteSegmentJson);

#!csharp

// End [Vector3]:
// {X:-277.4299, Y:-45.3671, Z:0.0000}
// Start [Vector3]:
// {X:-253.0895, Y:16.2591, Z:0.0000}
var start = new Vector3(-253.0895, 16.2591, 0.0000);
var end = new Vector3(-277.4299, -45.3671, 0.0000);
var line = new Line(start, end);

#!csharp

return siteSegments.Any((ss) => {
    return line.Start.DistanceTo(ss.Start) < 0.01 && line.End.DistanceTo(ss.End) < 0.01;
});

#!csharp

return DrawCurves(lines);

#!csharp

var pgonJson = "{\"discriminator\":\"Elements.Geometry.Polygon\",\"Vertices\":[{\"X\":-250.68175147156572,\"Y\":22.355056957539183,\"Z\":0.0},{\"X\":-277.42988663579314,\"Y\":-45.367092465552034,\"Z\":-5.10702591327572E-14},{\"X\":-195.9520960760371,\"Y\":-45.36709246555205,\"Z\":0.0},{\"X\":-195.9520960760371,\"Y\":22.355056957539176,\"Z\":0.0}]}";
var pgon = JsonConvert.DeserializeObject<Polygon>(pgonJson);
return DrawCurves(new [] { pgon });

#!markdown

# Bar Massing Strategies

#!csharp

static Polygon Shifted(this Polygon p, double dist) {
    return p.TransformedPolygon(new Transform((dist, 0,0)));
}

#!csharp

static void Draw(this Model m, Curve c, Color col) {
    m.AddElement(new ModelCurve(c, new Material() {Color = col}));
}

static void Draw(this Model m, IEnumerable<Curve> c, Color col) {
    foreach(var crv in c) {
        m.AddElement(new ModelCurve(crv, new Material() {Color = col}));
    }
}

static void Draw(this Model m, IEnumerable<Profile> c, Color col) {
    foreach(var crv in c) {
        m.AddElements(crv.ToModelCurves(material: new Material() {Color = col}));
    }
}

static void Draw(this Model m, Profile c, Color col) {
        m.AddElements(c.ToModelCurves(material: new Material() {Color = col}));
    
}

#!csharp

Profile Donut(Profile p, double dist) {
    var offset = p.Offset(-dist);
    return offset.OrderBy(o => o.Area()).Last();
}

#!csharp

Profile L(Profile p, double dist, Model m = null) {
    var perim = p.Perimeter;
    var vertices = perim.Vertices;
    Polyline bestPl = null;
    var length = 0.0;
    for(int i=0;i<vertices.Count;i++) {
        var currVertex = i;
        var nextVertex = (i+1)%vertices.Count;
        var nextNextVertex = (i+2)%vertices.Count;
        var polyline = new Polyline(vertices[currVertex], vertices[nextVertex], vertices[nextNextVertex]);
        if(bestPl == null || polyline.Length() > length) {
            bestPl = polyline;
            length = polyline.Length();
        }
    }
    var offset = bestPl.OffsetOpen(dist / 2);
    var thickened = offset.Offset(dist / 2, EndType.Square);
    m?.Draw(offset, Colors.Purple);
    var intersected = Profile.Intersection(new [] {p}, thickened.Select(t => new Profile(t)));
    return intersected.OrderBy(o => o.Area()).Last();
}

#!csharp

Profile H(Profile p, double dist, Model m = null)
{
    var segments = p.Perimeter.Segments();
    var bestLength = 0.0;
    List<Line> winningSkeleton = null;
    foreach (var s in segments)
    {
        var perp = s.Direction().Cross(Vector3.ZAxis);
        var midPt = (s.PointAt(0.5) + p.Perimeter.Centroid()) * 0.5;
        var centerBar = new Line(midPt, midPt + perp * 0.1);
        var extended = centerBar.ExtendTo(segments);
        var oppSegment = segments.FirstOrDefault(s => extended.End.DistanceTo(s) < 0.01);
        var offset1 = oppSegment.Offset(dist / 2, false);
        var offset2 = s.Offset(dist / 2, false);
        m?.Draw(offset1, Colors.Pink);
        m?.Draw(offset2, Colors.Purple);
        centerBar.Intersects(offset1, out var ptA, true);
        centerBar.Intersects(offset2, out var ptB, true);
        centerBar = new Line(ptA, ptB);
        var skeleton = new List<Line> { centerBar, offset1, offset2 };
        var length = skeleton.Sum(l => l.Length());
        if (length > bestLength)
        {
            winningSkeleton = skeleton;
            bestLength = length;
        }
    }
    var skeletonOffsets = winningSkeleton.SelectMany(l => l.ToPolyline(1).Offset(dist / 2, EndType.Square)).Select(p => new Profile(p));
    var intersected = Profile.Intersection(skeletonOffsets, new[] { p });
    var intersection = intersected.OrderBy(o => o.Area()).LastOrDefault();
    m?.Draw(skeletonOffsets, Colors.Purple);
    return intersection;
}

#!csharp

var debugModel = new Model();
var profiles = new List<Profile> {
    new Polygon(
        (0,0),
        (0, 50),
        (50, 50),
        (50, 0)
    ).Reversed(),
    new Polygon(
        (0,0),
        (0, 50),
        (50, 70),
        (50, 0)
    ).Reversed().Shifted(60),
    new Polygon(
        (10,0),
        (0, 50),
        (20, 60),
        (50, 70),
        (50, 0)
    ).Reversed().Shifted(120),
    new Polygon(
        (10,0),
        (0, 50),
        (20, 60),
        (50, 70),
        (55, 30),
        (50, 0)
    ).Reversed().Shifted(180)
};
debugModel.Draw(profiles, Colors.Red);
var Hs = profiles.Select(p => H(p, 10, debugModel)).ToList();
debugModel.Draw(Hs, Colors.Blue);
return debugModel;

#!csharp

var p = JsonConvert.DeserializeObject<Profile>(File.ReadAllText("../p.json"));

#!csharp

var m = new Model();
m.Draw(p, Colors.Red);
try {
    var h = H(p, 17.5, m);
    m.Draw(h, Colors.Blue);
} catch {
    
}
return m;
